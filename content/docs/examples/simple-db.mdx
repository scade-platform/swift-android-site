---
title: Simple Database
description: An example showing the usage of one of the most popular Swift libraries GRDB.swift for working with SQLite3
---

# Simple Database

This example demonstrates how to build a simple database application using Swift on Android. It showcases the integration and usage of [GRDB.swift](https://github.com/groue/GRDB.swift), one of the most popular and powerful Swift libraries for working with SQLite databases.

This example implements a basic player management system with CRUD operations (Create, Read, Update, Delete), highlighting how Swift's modern syntax and GRDB's elegant API can be used to build robust database-driven applications that run seamlessly on Android platforms. The example is inspired by the original Demo provided in the [GRDB.swift repository](https://github.com/groue/GRDB.swift/tree/master/DemoApps).

Additionally, this example demonstrates how easy it is to integrate pure native libraries into Android applications built with Swift. It shows how the SQLite3 native library is seamlessly linked and packaged within the application, illustrating the straightforward process of incorporating native dependencies into your Swift Android projects.

This article is structured into two main parts: first, we'll create the app logic using Swift, and then we'll build the user interface in Android Studio, following the typical development workflow for Swift Android applications.

## App logic

### Create Xcode Project 


### Editing Package.swift

Now, we edit the ```Package.swift``` file to add the dependencies we need for our application. The resulting file should look like this:

```swift
// swift-tools-version: 5.10
// The swift-tools-version declares the minimum version of Swift required to build this package.

import Foundation
import PackageDescription

let package = Package(
		// Package.swift

    name: "SimpleDB",

    products: [
        .library(
            name: "SimpleDB",
            // We use dynamic library to be able to use it on Android
						type: .dynamic,
            targets: ["SimpleDB"])
    ],

    dependencies: [
			// We use the Swift4j package to mark the Swift code that should be available on Android as Java API
      .package(url: "https://github.com/scade-platform/swift4j.git", from: "1.2.1")
			// We temporarily use a fork of GRDB.swift to ensure compatibility with Android
			// This branch includes necessary adjustments for Android compatibility and is wating for the official release
			// Once the official GRDB.swift supports Android, we can switch back to the main repository
			//.package(url: "https://github.com/groue/GRDB.swift.git", exact: "7.6.0")
			.package(url: "https://github.com/scade-platform/GRDB.swift.git", branch: "android_support")
    ],

    targets: [
        .target(
            name: "WeatherService",
            dependencies: [
							// We add the Swift4j package as a dependency to our target
              .product(name: "Swift4j", package: "swift4j")
            ]
        )
    ]
)
```

In this configuration, we changed the type of the library product to `.dynamic`, which is necessary for the library to be usable on Android. We also added a dependency on the `Swift4j` package, which provides the necessary functionality to expose Swift code as Java API.

We also added a dependency on the `GRDB.swift` package, pointing to a fork that includes necessary adjustments for Android compatibility. This is a temporary solution until the official GRDB.swift supports Android.

### Implementing the Database Logic

Next, we implement the core logic of our simple database application. Create a class named Database in the file ```Sources/SimpleDB/SimpleDB.swift```. This class will handle:
- Connecting to the SQLite database
- Performing CRUD operations on the player data

```swift
import Foundation
import GRDB
import Swift4j

// Take the code from the Database.swift file
```

Also, create a struct named Player to represent the player data model. The Player struct will include properties such as id, name, and score:

```swift
@jvm
struct Player: Codable, FetchableRecord, MutablePersistableRecord {
  /// The unique identifier for the player (auto-incremented).
  var id: Int64? = nil
  /// The name of the player.
  var name: String
  /// The score of the player.
  var score: Int

  /// Called after the player is inserted into the database to update the id.
  ///
  /// - Parameter inserted: The insertion result containing the new row ID.
  @nonjvm mutating func didInsert(_ inserted: InsertionSuccess) {
    // Update the id with the inserted row ID
    id = inserted.rowID
  }
}
```



## Reuse Swift code on Android

### Create new Android project

### Setup the gradle config file in the app directory

To use the `Database` and `Player` classes in the Android application, add the Swift Package as a dependency:
  1. Open the `build.gradle.kts` file located inside the `app` folder (**IMPORTANT**: there are usually two `build.gradle.kts` files; use the one in the `app` folder).
  2. Add the *Swift Packages for Gradle* plugin to the `plugins` block, and then add a configuration section for the plugin specifying the Swift Package to use.

The resulting file should look like this:

```kotlin
plugins {
		// The first two plugins are generated by the Android Studio wizard
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)

		// We add the Swift Packages for Gradle plugin to the project
    id("io.scade.gradle.plugins.android.swiftpm") version "1.1.1"
}

android {
	// This part remains untouched and is generated by the Android Studio wizard
}

dependencies {
	// We add a dependency to the native SQLite3 library, which is required by GRDB.swift
	// This library is provided within an AAR archive and is built from official SQLite3 sources 
	implementation("io.scade.android.lib:sqlite3:3.49.0")

	// This part remains untouched and is generated by the Android Studio wizard
}

swiftpm {
    path = file("../../../Packages/SimpleDB")
		product = "SimpleDB"    
    javaVersion = 8

		// We link native binaries from the SQLite3 AAR archive to the application
    dependencies {
        link("io.scade.android.lib:sqlite3:3.49.0")
    }
}
```

First, we add the *Swift Packages for Gradle* plugin to our project, that will take care of building the Swift Package, generating Java API as well as packaging everthing inside the finel application.

Next, we add a configuration block for the plugin, where we specify the path to the Swift Package we want to use, the name of the product we want to use from this package and the Java version we want to be compatible with (the default is 11, we use 8 because we want to support older versions of the Android API ).

Also, we add a dependency to the native *SQLite3* library into the plugin's configuration block, which is required by *GRDB.swift* to build. This library is available on Apple platforms as a binary but not on Android. The Swift PM plugin allows to link binary libraries from AAR archives what make possible to transparently ship all required binaries within AAR archives using the standard Gradle machanisms.

### Bind Swift logic to Android UI control