---
title: Weather Service
description: Retrieve the current temperature for any city or location
---

This example demonstrates how to build a weather service application that retrieves current temperature information for any city or geographic location. The app showcases real-world usage of networking and data parsing capabilities by integrating with external APIs to fetch and process weather data.

The Weather Service example highlights the most commonly used features from the Foundation framework:

- **Networking**: Making asynchronous HTTP requests using `URL` to communicate with external APIs
- **JSON Parsing**: Processing JSON responses using `JSONSerialization` to extract meaningful data from API responses

The application uses two different APIs:
- **Open-Meteo** - retrieves weather data
- **OpenStreetMap Nominatim** - geocodes city names into coordinates
The app shows how to chain multiple API calls and handle different response formats.

To build this weather service application, we split our task into two distinct parts described in the following sections: first, we develop the core app logic using Swift to handle data fetching and processing, and then we create the user interface targeting this logic in Android Studio.

The full source code together with an Android Studio project for this example is available on [GitHub](https://github.com/scade-platform/swift4j-examples)

## App logic in Swift

We start by implementing the core logic of our weather service application in Swift. First, we generate a new Swift Package using the standard ```swift```command line tool that is available in the Swift toolchain:

```bash
swift package init --type library --name WeatherService
```

For this step we can just use the Swift toolchain shipped within the Xcode.

The command generates a new Swift Package with one target named `WeatherService` as well as a library product with the same name consisting of this target. Now, we edit the ```Package.swift``` file to add the dependencies we need for our application. The resulting file should look like this:

```swift
// swift-tools-version: 5.10
// The swift-tools-version declares the minimum version of Swift required to build this package.

import Foundation
import PackageDescription

let package = Package(
		// Package.swift

    name: "WeatherService",

    products: [
        .library(
            name: "WeatherService",
            // We use dynamic library to be able to use it on Android
						type: .dynamic,
            targets: ["WeatherService"])
    ],

    dependencies: [
			// We use the Swift4j package to mark the Swift code that should be available on Android as Java API
      .package(url: "https://github.com/scade-platform/swift4j.git", from: "1.2.1")
    ],

    targets: [
        .target(
            name: "WeatherService",
            dependencies: [
							// We add the Swift4j package as a dependency to our target
              .product(name: "Swift4j", package: "swift4j")
            ]
        )
    ]
)
```

In this configuration, we changed the type of the library product to `.dynamic`, which is necessary for the library to be usable on Android. We also added a dependency on the `Swift4j` package, which provides the necessary functionality to expose Swift code as Java API.

### WeatherService class

Next, we can start implementing the core logic of our weather service application. We will create a class named `WeatherService` in the ```Sources/WeatherService/WeatherService.swift``` file that will handle fetching weather data from the Open-Meteo API and geocoding city names using the OpenStreetMap Nominatim API. The shorted version of the code (omitting exception logging) is presented below:

```swift
import Foundation
import Swift4j

@jvm
class WeatherService {
  /// This method makes a network request to the Open-Meteo API to retrieve the
  /// current temperature at the given coordinates. The result is returned via the
  /// response closure. If the request fails or the data cannot be parsed, the closure is not called.
  private func currentTemperature(latitude: Double, longitude: Double, _ response: (Float, String) -> Void) async {
    // Construct the API URL for the given coordinates
    let url = URL(string: "https://api.open-meteo.com/v1/forecast?latitude=\(latitude)&longitude=\(longitude)&current=temperature_2m")!

    do {
      // Perform the network request asynchronously
      let (data, _) = try await URLSession.shared.data(from: url)

      // Parse the JSON response to extract temperature and units
      guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
            let current = json["current"] as? [String: Any],
            let current_units = json["current_units"] as? [String: Any],
            let current_temp = current["temperature_2m"] as? Double,
            let current_temp_units = current_units["temperature_2m"] as? String else { return }

      // Call the response closure with the temperature and units
      response(Float(current_temp), current_temp_units)

    } catch {  }
  }

  /// This method first geocodes the city name to latitude and longitude using the
  /// OpenStreetMap Nominatim API, then fetches the current temperature for those coordinates.
  /// If the city cannot be found or the request fails, the closure is not called.
  func currentTemperature(city: String, _ response: (Float, String) -> Void) async {
    do {
      // Construct the geocoding API URL for the city
      let url = URL(string: "https://nominatim.openstreetmap.org/search?city=\(city)&format=json")!
      // Perform the network request asynchronously
      let (data, _) = try await URLSession.shared.data(from: url)

      // Parse the JSON response to extract latitude and longitude
      guard let json = try JSONSerialization.jsonObject(with: data) as? [Any],
            let cityData = json.first as? [String: Any] else { return }

      guard let lat = cityData["lat"] as? String,
            let lon = cityData["lon"] as? String else { return }

      // Convert latitude and longitude to Double and fetch temperature
      if let lat = Double(lat), let lon = Double(lon) {
        await currentTemperature(latitude: lat, longitude: lon, response)

      }
    } catch { }
  }
}
```

In this code, we define a class `WeatherService` with two asynchronous methods:
- **currentTemperature(latitude:longitude:response:)** - fetches temperature from Open-Meteo at given coordinates
- **currentTemperature(city:response:)** - geocodes a city name to coordinates and then fetching the temperature for those coordinates by calling the first function.

The implementation of both functions is based on the standard functionality provided by the `Foundation` framework, such as `URL` for networking and `JSONSerialization` for parsing JSON data. Both functions use Swift's `async/await` syntax to handle asynchronous operations, and the `response` closure is called with the temperature and its units when the data is successfully fetched and parsed.

The code presented above can be used on any Apple platform without any restriction. The whole magic of making it available on Android is done by the `Swift4j` package, which allows us to mark the Swift class and its methods as Java API using the `@jvm` attribute. This way, the `WeatherService` class and its methods can be called from Java code in an Android application without any additional boilerplate code. Please, note that we make the first function private, so it is not visible in the Java API, while the second function is public and can be called from Java code.

The full source code of the package is available on [GitHub](https://github.com/scade-platform/swift4j-examples/tree/main/Packages/WeatherService).

Now is the time to move to the Android part of the application.

## User interface on Android

We create a new Android project in Android Studio. For this, we can use the *New Project* wizard and select the *Empty Activity* template as well as the *Kotlin DSL* as the *Build configuration language*  that will create a new Android project with the necessary files and configurations.

In order to use the `WeatherService` class in our Android application, we need to add the Swift Package as a dependency. To do this, we can open the `build.gradle.kts` file located inside the `app` folder (**IMPORTANT**: usually, there are two `build.gradle.kts` files: one located at the root of the project and the second is inside the `app` folder, that defines the actual build tasks and configuration) of our project and add the *Swift Packages for Gradle* plugin to the `plugins` block as well as a configuration section of the plugin to specify the Swift Package we want to use. The resulting file should look like this:

```kotlin
plugins {
		// The first two plugins are generated by the Android Studio wizard
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)

		// We add the Swift Packages for Gradle plugin to the project
    id("io.scade.gradle.plugins.android.swiftpm") version "1.1.1"
}

android {
	// This part remains untouched and is generated by the Android Studio wizard
}

dependencies {
	// This part remains untouched and is generated by the Android Studio wizard
}

swiftpm {
    path = file("../../Packages/WeatherService")
    product = "WeatherService"
    javaVersion = 8
    scdAutoUpdate = true
}
```

First, we add the *Swift Packages for Gradle* plugin to our project, that will take care of building the Swift Package, generating Java API as well as packaging everthing inside the finel application.

Next, we add a configuration block for the plugin, where we specify the path to the Swift Package we want to use, the name of the product we want to use from this package and the Java version we want to be compatible with (the default is 11, we use 8 because we want to support older versions of the Android API ). The last parameter specify whether we want to automatically update the *Swift Toolchain for Android*.

After this, we can just build the project, if you don't have the *Swift Toolchain for Android* installed, the plugin will download it automatically and install it. If you already have the toolchain installed, the plugin will check the installed version and update it if a new version is available. Also, the plugin will generate the Java API for the `WeatherService` class so that we can immedately access it from our Kotlin code.

### MainActivity.kt

Now, we can open the `MainActivity.kt` file and implement the user interface logic. For the sake of simplicity we just add a label that will show the current temperature for a given city. First, we add an import statement for the `WeatherService` class exported from the Swift package previously at the top of the file:

```kotlin
import WeatherService.WeatherService
```

The Java API class and package names are generated based on the Swift target name and the class name, so in this case, the target is `WeatherService` and the class is `WeatherService`.

Next, we add the User-Interface related logic and calling the `WeatherService` to the `MainActivity` class. The complete code of the `MainActivity.kt` file is presented below:

```kotlin
class MainActivity : ComponentActivity() {
    private val temperatureText = mutableStateOf("Current temperature: retrieving...")
    private lateinit var weather: WeatherService

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

				// Setting up the user interface using Jetpack Compose
        enableEdgeToEdge()
        setContent {
            WeatherAppTheme {
                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
                    Temperature(
                        modifier = Modifier.padding(innerPadding)
                    )
                }
            }
        }

        // Calling the WeatherService to get the current temperature in Berlin
        System.loadLibrary("WeatherService")

        weather = WeatherService()
        weather.currentTemperature("Berlin") { temp, units ->
            temperatureText.value = "Current temperature in Berlin: $temp $units"
        }
    }


    @Composable
    fun Temperature(modifier: Modifier = Modifier) {
        val text by temperatureText
        Text(
            text = "$text!",
            modifier = modifier
        )
    }
}
```

In the code above, we create a mutable state variable `temperatureText` to hold the current temperature text that will be displayed in the user interface. By default, it is set to "Current temperature: retrieving...". Next, we setup the user interface using Jetpack Compose, where we define a `Temperature` composable function that displays the current temperature text. Finally, we load the `WeatherService` library containing our application logic, and call the `WeatherService` to get the current temperature in Berlin by calling the `currentTemperature(city:response:)` method and updating the `temperatureText` variable inside the Kotlin lambda passed to the function as a callback. Please, note that we can just pass a Kotlin lambda to the Swift function and it will be called asynchronously when the data is available.

The full source code of the Android application is available on [GitHub](https://github.com/scade-platform/swift4j-examples/tree/main/Android/WeatherApp).
